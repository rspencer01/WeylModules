#############################################################################
InstallMethod(IsWithin, 
"for a sub quotient Weyl module and a given weight vector", true, 
[IsSubQuotientWeylModule,IsLeftAlgebraModuleElement], 0, 
function(S,vec)
 # Returns true if the given <vec> lies within the given submodule S
 local Q,h,V,rowbasis, v, rowvec, SS; 
 Q:=S!.quotientWeylModule;
 V:=AmbientWeylModule(Q);
 h:= Q!.homomorphism;

 rowbasis:=S!.repbasis;
 SS:= VectorSpace(GF(V!.prime), rowbasis);
 rowvec:= Image(h, RowVec(V,vec));
 if rowvec in SS then
    return true;
 else
    return false;
 fi;
end );  

#############################################################################
InstallMethod(SubWeylModule, "for a quotient Weyl module and vector", true, 
[IsQuotientWeylModule,IsLeftAlgebraModuleElement], 0, 
function(Q,vec)
 # finds a basis for the submodule of <Q> generated by <vec>
 local i,j,k,rowbasis,lbasis,newvec,rowvec,S,L,
       p,zerotensor,extendbasis,g,gens,noPosRoots,v,
       height,comps,wt,W,h,SM;

 W:= AmbientWeylModule(Q);
 if vec = Generator(W) then
    lbasis:= BasisVecs(Q);
    rowbasis:=[];
    for v in lbasis do
       Add(rowbasis, RowVec(W,v));
    od;   
    SM:=Objectify(NewType(FamilyObj(Q), IsSubQuotientWeylModule),
     rec(eltbasis:=lbasis,repbasis:=rowbasis,gens:=[vec],
     quotientWeylModule:=Q) );
    return(SM);
 fi;

 h:= Q!.homomorphism;
 p:= W!.prime;
 wt:= W!.highestWeight;
 height:= HighestPrimePower(p, Sum(wt));

 L:= W!.LieAlgebra;
 g:= LatticeGeneratorsInUEA( L );
 noPosRoots:= Length(ChevalleyBasis(L)[1]);
 gens:= g{ [1..2*noPosRoots] };
 for i in [1..height] do
    for j in [1..2*noPosRoots] do
       Add(gens, gens[j]^(p^i)/Factorial(p^i));
    od;
 od;

 rowbasis:= [ Image(h, RowVec(W,vec)) ]; lbasis:= [ vec ];
 S:= VectorSpace(GF(p), rowbasis);   

 extendbasis:= function(v)
   local i;
   for i in gens do
       newvec:= ActOn(Q, i, v);
       if newvec <> 0*v then  
         rowvec:= Image(h, RowVec(W,newvec));
         if not (rowvec in S) then
            Add( rowbasis, rowvec);
            S:= VectorSpace(GF(p), rowbasis);
            Add( lbasis, newvec );
         fi;
       fi;
   od;
 end;

 extendbasis(vec); 
 j:=2;
 while j <= Length(lbasis) do
    extendbasis(lbasis[j]); 
    j:= j+1;
 od;

 SM:=Objectify(NewType(FamilyObj(Q), IsSubQuotientWeylModule),
     rec(eltbasis:=lbasis,repbasis:=rowbasis,gens:=[vec],
     quotientWeylModule:=Q) );
 return(SM);
end );


#############################################################################
InstallMethod(SubWeylModule, "for a sub quotient and a vector", true, 
[IsSubQuotientWeylModule, IsLeftAlgebraModuleElement], 0, 
function(W,vec)
 # Returns the submodule of the ambient quotient Weyl module generated by the
 # given submodule <W> and given vector <vec>.

 local Q, p, U, rowbasis, lbasis, S, generators, ulbasis, urowbasis, i, SM;

 Q:=W!.quotientWeylModule; p:=AmbientWeylModule(Q)!.prime;
 lbasis:=ShallowCopy(W!.eltbasis);
 if Length(lbasis) = 0 then  # W is the zero module
    return( SubWeylModule(Q,vec) );
 fi;
 rowbasis:=ShallowCopy(W!.repbasis);
 generators:=ShallowCopy(W!.gens);
 Add(generators, vec);

 U:=SubWeylModule(Q,vec);
 ulbasis:= U!.eltbasis;
 urowbasis:=U!.repbasis;
 for i in [1..Length(ulbasis)] do
   S:=VectorSpace(GF(p), rowbasis);
   if not (urowbasis[i] in S) then
     Add(lbasis, ulbasis[i]);
     Add(rowbasis, urowbasis[i]);
   fi;
 od;

 SM:=Objectify(NewType(FamilyObj(Q), IsSubQuotientWeylModule),
     rec(eltbasis:=lbasis,repbasis:=rowbasis,gens:=generators,
     quotientWeylModule:=Q) );
 return(SM);
end );

#############################################################################
InstallMethod(SubWeylModule, 
"for a quotient Weyl module and list of vectors", true, 
[IsQuotientWeylModule, IsList], 0, 
function(Q,vecs)
 # Returns the sub quotient module generated by the given vectors

 local S,v,SM;
 if Length(vecs) = 0 then
    SM:=Objectify(NewType(FamilyObj(Q), IsSubQuotientWeylModule),
     rec(eltbasis:=[],repbasis:=[],gens:=[],
     quotientWeylModule:=Q) );
 return(SM);
 fi;
 
 S:= SubWeylModule(Q, vecs[1]);
 for v in vecs{ [2..Length(vecs)] } do
   S:= SubWeylModule(S,v);
 od;
 return( S );
end );

#############################################################################
InstallMethod(PrintObj, "for a sub quotient Weyl module", true,
[IsSubQuotientWeylModule], 0,
function(S)
 Print("<SubQuotient WeylModule of dimension ", Dim(S),
 ", generated by elements ", S!.gens, " of weights ",
 List(S!.gens, Weight), ">, in\n", S!.quotientWeylModule);
end );

#############################################################################
InstallMethod(Generators, "for a sub quotient Weyl module", true,
[IsSubQuotientWeylModule], 0,
function(S)
 return(S!.gens);
end );

#############################################################################
InstallMethod(BasisVecs, "for a sub quotient Weyl module", true,
[IsSubQuotientWeylModule], 0,
function(S)
 # returns the basis vectors of <S>
 return(S!.eltbasis);
end );

#############################################################################
InstallMethod(Dim, "for a sub quotient Weyl module", true,
[IsSubQuotientWeylModule], 0,
function(S)
 # returns the dimension of <S>
 return(Length(S!.eltbasis));
end );

#############################################################################
InstallMethod(AmbientQuotient, "for a sub quotient Weyl module", true,
[IsSubQuotientWeylModule], 0,
function(S)
 # returns the ambient quotient Weyl module
 return(S!.quotientWeylModule);
end );

#############################################################################
InstallMethod(Weights, "for a sub quotient Weyl module", true, 
[IsSubQuotientWeylModule], 0, 
function(S)
 # returns a list of the weight space labels of <S>
 return( DuplicateFreeList(List(BasisVecs(S), Weight)) );
end );

#############################################################################
InstallMethod(WeightSpaces, "for a sub quotient Weyl module", true,
[IsSubQuotientWeylModule], 0,
function(S)
 # returns a list of the weight spaces of <S>
 local wts,out,w;

 wts:=Weights(S);
 out:= [ ];
 for w in wts do
   Add(out, w);
   Add(out, WeightSpace(S,w));
 od;
 return(out);
end );

#############################################################################
InstallMethod(Character, "for a sub quotient Weyl module", true, 
[IsSubQuotientWeylModule], 0, 
function(S)
 # returns the character (a list of the weights and their multiplicities)
 # for the given sub quotient Wey module S
 local ws, k, out;
 out:= [ ];
 ws:= WeightSpaces(S);
 for k in [2,4..Length(ws)] do
   Add(out, ws[k-1]);
   Add(out, Length(ws[k]));
 od;
 return(out);
end );

#############################################################################
InstallMethod(DominantWeightSpaces, "for a sub quotient Weyl module", true, 
[IsSubQuotientWeylModule], 0, 
function(S)
 # returns a list of the dominant weight spaces of S
 local out, k, ws;
 out:= [ ];
 ws:= WeightSpaces(S);
 for k in [2,4..Length(ws)] do
   if IsDominant( ws[k-1] ) then 
     Add(out, ws[k-1]);
     Add(out, ws[k]);
   fi;
 od;
 return(out);
end );

#############################################################################
InstallMethod(WeightSpace, "for a sub quotient Weyl module", true, 
[IsSubQuotientWeylModule,IsList], 0, 
function(S,wt)
 # returns a basis for the given weight space in <S> of weight <wt>
 local bb,out,b;
 bb:=BasisVecs(S); out:=[ ];
 for b in bb do
   if Weight(b) = wt then Add(out,b); fi;
 od;
 return(out);
end );

#############################################################################


