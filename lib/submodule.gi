
#############################################################################
InstallMethod(SubWeylModule, "for a Weyl module and vector", true, 
[IsWeylModule,IsLeftAlgebraModuleElement], 0, 
function(W,vec)
 # constructs the submodule of <W> generated by <vec>
 local i,j,k,rowbasis,lbasis,newvec,rowvec,S,L,
       p,extendbasis,g,gens,noPosRoots,height,comps,wt,SM,v;
  
 if vec = Generator(W) then
    lbasis:= BasisVecs(W);
    rowbasis:=[];
    for v in lbasis do
       Add(rowbasis, RowVec(W,v));
    od;   
    SM:=Objectify(NewType(FamilyObj(W), IsSubWeylModule),
       rec(eltbasis:=lbasis,repbasis:=rowbasis,gens:=[vec],weylModule:=W,
       maximalVecs:=[], maximalVecsAmbiguous:=[]) );
    return(SM);
 fi;

 p:= W!.prime;
 wt:= W!.highestWeight;
 height:= HighestPrimePower(p, Sum(wt));
 L:= W!.LieAlgebra;
 g:= LatticeGeneratorsInUEA( L );
 noPosRoots:= Length(ChevalleyBasis(L)[1]);
 gens:= g{ [1..2*noPosRoots] };
 for i in [1..height] do
    for j in [1..2*noPosRoots] do
       Add(gens, gens[j]^(p^i)/Factorial(p^i));
    od;
 od;

 rowbasis:= [ RowVec(W,vec) ]; lbasis:= [ vec ];
 S:= VectorSpace(GF(p), rowbasis);   

 extendbasis:= function(v)  # helper function
   local i;
   for i in gens do
       newvec:= (i^v) mod p;
       if newvec <> 0*v then  
         rowvec:= RowVec(W,newvec);
         if not (rowvec in S) then
            Add( rowbasis, rowvec);
            S:= VectorSpace(GF(p), rowbasis);
            Add( lbasis, newvec );
         fi;
       fi;
   od;
 end;

 extendbasis(vec); 
 j:=2;
 while j <= Length(lbasis) do
    extendbasis(lbasis[j]); 
    j:= j+1;
 od;
 
 SM:=Objectify(NewType(FamilyObj(W), IsSubWeylModule),
     rec(eltbasis:=lbasis,repbasis:=rowbasis,gens:=[vec],weylModule:=W,
     maximalVecs:=[], maximalVecsAmbiguous:=[]) );
 return(SM);
end );

#############################################################################
InstallMethod(SubWeylModule, "for a sub Weyl module and a vector", true, 
[IsSubWeylModule, IsLeftAlgebraModuleElement], 0, 
function(W,vec)
 # Returns the submodule of the ambient Weyl module generated by the
 # given submodule <W> and given vector <vec>.

 local V, p, U, rowbasis, lbasis, S, generators, ulbasis, urowbasis, i, SM;

 V:=W!.weylModule; p:=V!.prime;
 lbasis:=ShallowCopy(W!.eltbasis);
 if Length(lbasis) = 0 then  # W is the zero module
    return( SubWeylModule(V,vec) );
 fi;
 rowbasis:=ShallowCopy(W!.repbasis);
 generators:=ShallowCopy(W!.gens);
 Add(generators, vec);

 U:=SubWeylModule(V,vec);
 ulbasis:= U!.eltbasis;
 urowbasis:=U!.repbasis;
 for i in [1..Length(ulbasis)] do
   S:=VectorSpace(GF(p), rowbasis);
   if not (urowbasis[i] in S) then
     Add(lbasis, ulbasis[i]);
     Add(rowbasis, urowbasis[i]);
   fi;
 od;

 SM:=Objectify(NewType(FamilyObj(V), IsSubWeylModule),
     rec(eltbasis:=lbasis,repbasis:=rowbasis,gens:=generators,
     weylModule:=V, maximalVecs:=[], maximalVecsAmbiguous:=[]) );
 return(SM);
end );

#############################################################################
InstallMethod(SubWeylModule, "for a Weyl module and list of vectors", true, 
[IsWeylModule, IsList], 0, 
function(V,vecs)
 # Returns the sub Weyl module generated by the given vectors

 local S, v, SM;
 if Length(vecs) = 0 then
   SM:=Objectify(NewType(FamilyObj(V), IsSubWeylModule),
     rec(eltbasis:=[],repbasis:=[],gens:=[],
     weylModule:=V, maximalVecs:=[], maximalVecsAmbiguous:=[]) );
   return(SM);
 fi;
 
 S:= SubWeylModule(V, vecs[1]); # to start
 for v in vecs{ [2..Length(vecs)] } do
   S:= SubWeylModule(S,v);
 od;
 return(S);
end );

#############################################################################
InstallMethod(SubWeylModuleDirectSum,
"for a Weyl module and a list of sub Weyl modules", true,
[IsWeylModule,IsList], 0,
function(V,inlist)
 # returns the direct sum of the inputs (which are assumed independent)
 # Note: No checking of the assumption is done!

 local S, lbasis, rowbasis, generators, SM;

 lbasis:= []; rowbasis:= []; generators:= [];
 for S in inlist do
    Append(lbasis, S!.eltbasis);
    Append(rowbasis, S!.repbasis);
    Append(generators, S!.gens);
    Assert(0,V = S!.weylModule);
 od;

 SM:= Objectify(NewType(FamilyObj(V), IsSubWeylModule),
     rec(eltbasis:=lbasis,repbasis:=rowbasis,gens:=generators,
     weylModule:=V, maximalVecs:=[], maximalVecsAmbiguous:=[]) );
 return(SM);
end );

#############################################################################
InstallMethod(PrintObj, "for a sub Weyl module", true,
[IsSubWeylModule], 0,
function(S)
 Print("<SubWeylModule of dimension ", Dim(S), ", generated by elements ",
 S!.gens, " of weights ", List(S!.gens, Weight), ">, in\n", S!.weylModule);
end );

#############################################################################
InstallMethod(IsAmbiguous,  "for a sub Weyl module", true, 
[IsSubWeylModule], 0, 
function(W)
  if Length(W!.maximalVecsAmbiguous) > 0 then return true; fi;
  return false;
end );

#############################################################################
InstallMethod(AmbiguousMaxVecs,  "for a sub Weyl module", true, 
[IsSubWeylModule], 0, 
function(W)
  return(W!.maximalVecsAmbiguous);
end );

#############################################################################
InstallMethod(Generators, "for a sub Weyl module", true,
[IsSubWeylModule], 0,
function(S)
 return(S!.gens);
end );

#############################################################################
InstallMethod(BasisVecs, "for a sub Weyl module", true,
[IsSubWeylModule], 0,
function(S)
 # returns the basis vectors of <S>
 return(S!.eltbasis);
end );

#############################################################################
InstallMethod(Dim, "for a sub Weyl module", true,
[IsSubWeylModule], 0,
function(S)
 # returns the dimension of <S>
 return(Length(S!.eltbasis));
end );

#############################################################################
InstallMethod(AmbientWeylModule, "for a sub Weyl module", true,
[IsSubWeylModule], 0,
function(S)
 # returns the ambient Weyl module
 return(S!.weylModule);
end );

#############################################################################
InstallMethod(Weights, "for a sub Weyl module", true, 
[IsSubWeylModule], 0, 
function(S)
 # returns a list of the weight space labels of <S>
 return( DuplicateFreeList(List(BasisVecs(S), Weight)) );
end );

#############################################################################
InstallMethod(DominantWeights, "for a sub Weyl module", true, 
[IsSubWeylModule], 0, 
function(V)
 # returns a list of the dominant weight space labels of <V>
 local out,item;
 out:= [];
 for item in Weights(V) do
   if IsDominant(item) then Add(out, item); fi;
 od;
 return(out);
end );

#############################################################################
InstallMethod(WeightSpaces, "for a sub Weyl module", true,
[IsSubWeylModule], 0,
function(S)
 # returns a list of the weight spaces of <S>
 local wts,out,w;

 wts:=Weights(S);
 out:= [ ];
 for w in wts do
   Add(out, w);
   Add(out, WeightSpace(S,w));
 od;
 return(out);
end );

#############################################################################
InstallMethod(Character, "for a sub Weyl module", true, 
[IsSubWeylModule], 0, 
function(S)
 # returns the character (a list of the weights and their multiplicities)
 # for the given sub Wey module S
 local ws, k, out;
 out:= [ ];
 ws:= WeightSpaces(S);
 for k in [2,4..Length(ws)] do
   Add(out, ws[k-1]);
   Add(out, Length(ws[k]));
 od;
 return(out);
end );

#############################################################################
InstallMethod(DominantWeightSpaces, "for a sub Weyl module", true, 
[IsSubWeylModule], 0, 
function(S)
 # returns a list of the dominant weight spaces of S
 local out, k, ws;
 out:= [ ];
 ws:= WeightSpaces(S);
 for k in [2,4..Length(ws)] do
   if IsDominant( ws[k-1] ) then 
     Add(out, ws[k-1]);
     Add(out, ws[k]);
   fi;
 od;
 return(out);
end );

#############################################################################
InstallMethod(WeightSpace, "for a sub Weyl module", true, 
[IsSubWeylModule,IsList], 0, 
function(S,wt)
 # returns a basis for the given weight space in <S> of weight <wt>
 local bb,out,b;
 bb:=BasisVecs(S); out:=[ ];
 for b in bb do
   if Weight(b) = wt then Add(out,b); fi;
 od;
 return(out);
end );


# The following is for testing purposes only, and is not documented.
#############################################################################
InstallMethod(SubWeylModule, 
"for a Weyl module, target dimensions, and a list of weight vectors", true, 
[IsWeylModule,IsPosInt,IsPosInt,IsList], 0, 
function(V,low,high,wtspace)
 # Returns a submodule of dimension not more than <dim>, 
 # generated by a linear combination of the given list of weight vectors.
 # Returns 'fail' if no such submodule is found.
 local zerovec, testcases,coeff,vec,p,sub;
 p:= V!.prime;
 zerovec:= 0*wtspace[1];
 testcases:= Tuples( [0..p-1], Length(wtspace) );
 for coeff in testcases do
   vec:= LinearCombination(wtspace, coeff); 
   if not vec = zerovec then 
      sub:= SubWeylModule(V,vec);
      if Length(sub) <= high and low <= Length(sub) then return(sub); fi; 
   fi;
 od;
 return( fail );
end );

#############################################################################
InstallMethod(IsMaximalVector, 
        "for a sub Weyl module and a weight vector", true, 
        [IsSubWeylModule,IsLeftAlgebraModuleElement], 0, 
function(S,vec)
 # Tests <vec> to see if it is maximal in <V>/<S>, for the 
 # given submodule <S>. In other words,
 # if this returns "true" then <vec> is primitive in <V>.
 
 local V,rank,j,k,p,zerovec,height,xy,xsimple,ysimple;
 V:= AmbientWeylModule(S);
 p:= V!.prime;
 xy:= SimpleLieAlgGens(V); xsimple:=xy[1]; ysimple:=xy[2];
 zerovec:= 0*vec;
 rank:= Length(xsimple);
 height:= HighestPrimePower(p, Sum(V!.highestWeight));
 for j in [1..rank] do 
     for k in [0..height] do 
       if not IsWithin(S,(xsimple[j]^(p^k)/Factorial(p^k))^vec mod p) then
         return(false); fi;
     od;
 od;
 return(true);
end );

#############################################################################
# At the moment, operations depending on the following are not likely
# to work if we obtain more than one independent maximal vector in the
# given weight space. In such a case, the multiple maximal vectors in
# question are stored in the Weyl module, and a warning is printed.
#############################################################################
InstallMethod(MaximalVectors, "for a sub Weyl module and weight", true,
[IsSubWeylModule,IsList], 0, function(sub,wt)
# Returns maximal vectors of a given weight space in a submodule, if possible

 local V,rank,i,j,k,p,height,vec,rowvec,finalmatrix,wtspace,
       item,outlist,result,join,matrix,xy,xsimple,ysimple,z;

 join:= function(A,B)
   # Given matrices A,B compute an augmented matrix M such that the
   # left nullspace of M equals the intersection of the left nullspaces
   # of A and B. 
   local tA,tB,CS,vec,p; 
   p:= V!.prime;
   tA:= TransposedMatMutable(A); tB:= TransposedMatMutable(B);
   if Length(tA) = 0 then tA:= tB; fi;
   CS:= VectorSpace(GF(p),tA);
   for vec in tB do
     if not vec in CS then 
       Add(tA, vec);
       CS:= VectorSpace(GF(p),tA);
     fi;
   od;
   return( TransposedMatMutable(tA) );
   end; 

 V:= AmbientWeylModule(sub);
 p:= V!.prime;
 wtspace:= WeightSpace(sub,wt);
 xy:= SimpleLieAlgGens(V); xsimple:=xy[1]; ysimple:=xy[2];
 rank:= Length(xsimple);
 height:= HighestPrimePower(p, Sum(V!.highestWeight));
 finalmatrix:= [];
 for j in [1..rank] do 
   for k in [0..height] do
     matrix:= []; 
     for vec in wtspace do
       rowvec:= RowVec(V, (xsimple[j]^(p^k)/Factorial(p^k))^vec mod p );
       Add(matrix, rowvec);
     od;
     finalmatrix:= join(finalmatrix, matrix); 
   od;
 od;
 
 z:= NullspaceMatDestructive(finalmatrix);
 outlist:= [];
 for item in z do
   result:= 0*wtspace[1];
   for i in [1..Length(item)] do
     result:= result + IntFFESymm(item[i])*wtspace[i];
   od;
   Add(outlist, result);
 od;
 if Length(outlist) > 1 then
    Add(sub!.maximalVecsAmbiguous, outlist);
    if Length(sub!.maximalVecsAmbiguous) = 1 then # first time
       Print("***** WARNING: Ambiguous submodule detected *****\n");
    fi;
 fi; 
 return(outlist);
end );  

#############################################################################
InstallMethod(MaximalVectors, "for a sub Weyl module", true, 
[IsSubWeylModule], 0, 
function(S)
 # Finds a maximal vector in each weight space of given submodule <S>, 
 # if possible 
 local V,k,max,wts,out;
 V:= AmbientWeylModule(S);
 if S!.maximalVecs = [] then   
   wts:= DominantWeights(S);
   out:= [ ];
   for k in [1..Length(wts)] do
     max:= MaximalVectors(S,wts[k]);
     if Length(max) > 0 then
       Append(out, max);
     fi;
   od;
   S!.maximalVecs:= out; #remember for next time
   return( out );
 else
   return( S!.maximalVecs );
 fi;
end );

#############################################################################
InstallMethod(IsWithin, 
"for a sub Weyl module and a given weight vector", true, 
[IsSubWeylModule,IsLeftAlgebraModuleElement], 0, 
function(S,vec)
 # Returns True if the given <vec> lies within the given submodule S
 local V,rowbasis, v, rowvec, SS; 
 V:=S!.weylModule;
 rowbasis:=S!.repbasis;
 SS:= VectorSpace(GF(V!.prime), rowbasis);
 rowvec:= RowVec(V,vec);
 if rowvec in SS then
    return true;
 else
    return false;
 fi;
end );  

#############################################################################
InstallMethod(SocleWeyl, "for a Weyl module", true, 
[IsWeylModule], 0, 
function(V)
 # Returns the socle of <V> 
 local mvecs,outlist,p,s,b,dima,dimb,k;
 p:= V!.prime;
 outlist:= []; 
 mvecs:= MaximalVectors(V);
 if Length(mvecs) = 1 then   # V is simple
     return SubWeylModule(V, mvecs[1]);
 fi;
 for k in [2,3..Length(mvecs)] do
     s:= SubWeylModule(V,mvecs[k]); 
     dima:= Dim(s);
     b:= SimpleCharacter(p,Weight(mvecs[k]),V!.type,V!.rank);
     dimb:=CharacterDim(b);
     if dima = dimb then
         Add(outlist, s);
     fi;
 od;
 return SubWeylModuleDirectSum(V,outlist);
end );
     
#############################################################################
InstallMethod(NextSocle, "for a sub Weyl module", true,
[IsSubWeylModule], 0, 
function(S)
 # Returns the next socle of V (the submodule that maps onto soc(V/S))

 local V, Q,mvecs, m, sub, lam, p, t, r, ans;
 V:= AmbientWeylModule(S);
 ans:= S; # initially
 p:=V!.prime; t:=V!.type; r:=V!.rank;

 Q:= QuotientWeylModule(S);
 mvecs:= MaximalVectors(Q);
 for m in mvecs do
    sub:= SubWeylModule(Q, m);
    lam:= Weight(m);
    if SortedCharacter(Character(sub))
       = SortedCharacter(SimpleCharacter(p,lam,t,r)) then
       ans:= SubWeylModule(ans, m);
    fi;
 od;
 return ans;
end );

#############################################################################
InstallMethod(GensNextSocle, "for a sub Weyl module", true,
[IsSubWeylModule], 0, 
function(S)
 # Returns a list of the maximal vectors of V/S generating its socle
 
 local V, Q, mvecs, m, sub, lam, p, t, r, socleVecs;
 V:= AmbientWeylModule(S);
 p:=V!.prime; t:=V!.type; r:=V!.rank;
 socleVecs:= [];
 Q:= QuotientWeylModule(S);
 mvecs:= MaximalVectors(Q);
 for m in mvecs do
    sub:= SubWeylModule(Q, m);
    lam:= Weight(m);
    if SortedCharacter(Character(sub))
       = SortedCharacter(SimpleCharacter(p,lam,t,r)) then
       Add(socleVecs, m);
    fi;
 od;
 return socleVecs;
end );

#############################################################################